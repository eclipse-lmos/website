"use strict";(self.webpackChunklmos_website=self.webpackChunklmos_website||[]).push([[9832],{5801:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"lmos_platform/lmos_router","title":"LMOS Router","description":"The LMOS Router is a vital component of the LMOS architecture. The LMOS Runtime and LMOS Router are usally part of a Supervisor Agent in a multi-agent system.","source":"@site/docs/lmos_platform/lmos_router.md","sourceDirName":"lmos_platform","slug":"/lmos_platform/lmos_router","permalink":"/lmos/docs/lmos_platform/lmos_router","draft":false,"unlisted":false,"editUrl":"https://github.com/eclipse-lmos/website/edit/source/docs/lmos_platform/lmos_router.md","tags":[],"version":"current","frontMatter":{"title":"LMOS Router"},"sidebar":"lmosSidebar","previous":{"title":"LMOS Control Plane","permalink":"/lmos/docs/lmos_platform/lmos_control_plane"},"next":{"title":"LMOS Runtime","permalink":"/lmos/docs/lmos_platform/lmos_runtime"}}');var r=n(4848),i=n(8453);const a={title:"LMOS Router"},o="LMOS Router",l={},c=[{value:"Routing Methods",id:"routing-methods",level:2},{value:"LLM-Based Approach",id:"llm-based-approach",level:3},{value:"Vector-Based Approach",id:"vector-based-approach",level:3},{value:"Hybrid Approach",id:"hybrid-approach",level:3}];function d(e){const t={h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"lmos-router",children:"LMOS Router"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.strong,{children:"LMOS Router"})," is a vital component of the LMOS architecture. The LMOS Runtime and LMOS Router are usally part of a Supervisor Agent in a multi-agent system."]}),"\n",(0,r.jsx)(t.p,{children:"Upon receiving a query, the LMOS Runtime loads relevant channel routing configurations (agent metadata) via the LMOS Operator based on the specific channel and tenant involved. This enables the LMOS Runtime to make an informed routing decision through the LMOS Router, which leverages either a Vector Database or a Large Language Model (LLM) for this purpose. Once a routing decision is made, the Supervisor Agent coordinates with multiple specialized AI Agents to execute the necessary tasks."}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.img,{alt:"LMOS Router",src:n(8738).A+"#light-mode-only",width:"1089",height:"479"}),"\n",(0,r.jsx)(t.img,{alt:"LMOS Router",src:n(928).A+"#dark-mode-only",width:"1089",height:"479"})]}),"\n",(0,r.jsx)(t.p,{children:"The LMOS Router relies on agent metadata to identify the most appropriate agent for a given task, based on the agent's capabilities. To achieve this, the Router offers three distinct methods:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"LLM-based Approach:"})," This method utilizes a language model to comprehend and match a task with the relevant agent's capabilities. It enables the Router to understand the context and requirements of the query at a deeper level, ensuring an optimal routing decision."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Vector-based Approach:"})," In this approach, semantic similarity is employed to identify the most suitable agent by comparing the query with agent profiles stored in a vector space. It helps the Router quickly determine the agent whose expertise most closely aligns with the task at hand."]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Hybrid Approach:"})," This method combines the strengths of both LLM and vector-based approaches. Initially, the LLM extracts abstract requirements from the query, and then the Router performs a semantic search to find the agent that best matches those requirements. The Hybrid Approach maximizes the effectiveness of both techniques, improving the quality and accuracy of routing decisions."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"routing-methods",children:"Routing Methods"}),"\n",(0,r.jsx)(t.h3,{id:"llm-based-approach",children:"LLM-Based Approach"}),"\n",(0,r.jsx)(t.p,{children:"Uses advanced language models like OpenAI's GPT-3.5 to understand the context and semantics of user queries."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Pros:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Understands complex queries and context."}),"\n",(0,r.jsx)(t.li,{children:"Flexible and adaptable to various scenarios."}),"\n",(0,r.jsx)(t.li,{children:"Utilizes state-of-the-art NLP techniques."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Cons:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Expensive due to commercial language model costs."}),"\n",(0,r.jsx)(t.li,{children:"Higher response times."}),"\n",(0,r.jsx)(t.li,{children:"Dependent on external APIs with potential rate limits."}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"vector-based-approach",children:"Vector-Based Approach"}),"\n",(0,r.jsx)(t.p,{children:"Uses vector embeddings to represent queries and agent capabilities, comparing them using cosine similarity."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Pros:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Fast and efficient for large-scale data."}),"\n",(0,r.jsx)(t.li,{children:"Scalable to handle more agents and queries."}),"\n",(0,r.jsx)(t.li,{children:"Independent of external APIs."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Cons:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Limited in understanding complex queries."}),"\n",(0,r.jsx)(t.li,{children:"Requires initial setup and regular updates."}),"\n",(0,r.jsx)(t.li,{children:"Needs maintenance for embedding updates."}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"hybrid-approach",children:"Hybrid Approach"}),"\n",(0,r.jsx)(t.p,{children:"Extracts abstract requirements from the query using an LLM and then searches for an agent using semantic similarity."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Pros:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Balances the strengths of both LLM and Vector-based approaches."}),"\n",(0,r.jsx)(t.li,{children:"Better understanding of complex queries than vector-based alone."}),"\n",(0,r.jsx)(t.li,{children:"More efficient than LLM-based alone."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Cons:"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Still dependent on external APIs for LLM."}),"\n",(0,r.jsx)(t.li,{children:"Requires integration of both LLM and vector-based systems."}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},928:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/supervisor_agent-dark-da394ead660cb7f231fafcfc280da389.png"},8738:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/supervisor_agent-light-9cdb235fcfb8b1c70f6fe9b8232a3e4e.png"},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(6540);const r={},i=s.createContext(r);function a(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);